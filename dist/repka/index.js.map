{
  "version": 3,
  "sources": ["../../packages/repka/repository.ts", "../../packages/repka/index.ts"],
  "sourcesContent": ["import { IWatcher, watcherCreator } from 'watcher';\n\nexport interface IRepositoryService {\n  <\n    RepositoryPort extends { [key: string]: unknown },\n    Controller = undefined,\n  >(\n    defaultObject?: RepositoryPort,\n    controller?: Controller & { repo?: IRepositoryService },\n  ): (() => [RepositoryPort, Omit<Controller, 'repo'>]) & RepositoryPort;\n\n  keys: string[];\n  actions: IWatcher<any, any>;\n  initializeState<T, M> (\n    data?: T,  \n    options?: { methods?: M, prevActions?: any, provider?: any }\n  ): void;\n  initRepository?<T, M> (repo?: T, options?: {\n    methods?: M, provider?: any, prevActions?: any\n  }): IWatcher<T, M>;\n\n  __call: <\n    RepositoryPort extends { [key: string]: unknown },\n    Controller = undefined,\n  >(\n    defaultObject?: RepositoryPort,\n    controller?: Controller & { repo?: IRepositoryService },\n  ) => (() => [RepositoryPort, Omit<Controller, 'repo'>]) & RepositoryPort;\n}\n\nexport class RepositoryService extends Function {\n  keys: string[];\n  actions: IWatcher<any, any>;\n  initializeState<T, M>(\n    data?: T,  \n    options?: { methods?: M, prevActions?: any, provider?: any }\n  ): void {};\n  initRepository?<T, M> (repo?: T, options?: {\n    methods?: M, provider?: any, prevActions?: any\n  }): IWatcher<T, M>;\n\n  __call: <\n    RepositoryPort extends { [key: string]: unknown },\n    Controller = undefined,\n  >(\n    defaultObject?: RepositoryPort,\n    controller?: Controller & { repo?: IRepositoryService },\n  ) => (() => [RepositoryPort, Omit<Controller, 'repo'>]) & RepositoryPort;\n\n  constructor() {\n    super();\n    let closure = undefined;\n    closure = (...args: any) => { \n      return closure.__call(...args); \n    };\n    return Object.setPrototypeOf(closure, new.target.prototype);\n  }\n}\n\ninterface initRepoBoundFunction {\n    <T, M>(rp?: T, options?: {\n      methods?: M,\n      provider?: any,\n      prevActions?: any\n    }): IWatcher<T, M>;\n    call<T, M>(this: Function, ...argArray: any[]): IWatcher<T, M>;\n}\nexport const initRepository: initRepoBoundFunction = function <T, M>(\n  repo: T,\n  options: {\n    methods?: M,\n    provider?: any,\n    prevActions?: any\n  } = {}\n): IWatcher<T, M> {\n  const keys = Object.keys(repo || {});\n\n  const withOnUpdate: T = keys.reduce((\n    prev: T, \n    curr: string\n  ) => {\n    let value: unknown;\n    if (options.prevActions !== undefined && options.prevActions.get(curr) !== undefined) {\n      value = options.prevActions.get(curr);\n    } else if (repo) {\n      value = repo[curr];\n    }\n    return { ...prev, [curr]: value };\n  }, repo || {} as T);\n\n  return watcherCreator<T, M>(\n    withOnUpdate, \n    options.provider, \n    options.methods\n  );\n}\n\nexport const initializeState = function<T, M>(\n  data?: T, \n  options: { methods?: M, prevActions?: any, provider?: any } = {}\n): void {\n  if (!options.prevActions) options.prevActions = this?.actions;\n  if (!options.provider) options.provider = this?.actions?.savedProvider;\n\n  const newActions = initRepository.call<T, M>(this, data, options);\n  this.actions = newActions;\n}\n\nfunction getAllMethodNames(toCheck) {\n    const props = [];\n    let obj = toCheck;\n    do {\n        props.push(...Object.getOwnPropertyNames(obj));\n    } while (obj = Object.getPrototypeOf(obj));\n    \n    return props.sort().filter((e, i, arr) => { \n       if (e!=arr[i+1] && typeof toCheck[e] == 'function') return true;\n    });\n}\n\nexport function repositoryCreator<\n  RepositoryPort extends { [key: string]: unknown },\n  Controller = undefined,\n>(\n  defaultObject?: RepositoryPort,\n  controller?: Controller & { repo?: IRepositoryService },\n  { provider }: {\n    provider?: any,\n    broadcastName?: string\n  } = {}\n): (() => [RepositoryPort, Omit<Controller, 'repo'>]) & RepositoryPort {\n  let methods: Controller;\n  let repo = null;\n\n  if (controller) {\n    const constructorKeys = getAllMethodNames(controller);\n\n    methods = constructorKeys.reduce(\n      (prev, curr) => (curr !== 'constructor' && typeof controller[curr] === 'function') \n        ? { ...prev, [curr]: controller[curr].bind(controller) }\n        : prev,\n      {} as Controller\n    );\n\n    const prevActions = controller.repo?.actions;\n    controller.repo = new RepositoryService() as IRepositoryService;\n    controller.repo.initRepository = initRepository;\n    controller.repo.initializeState = initializeState;\n    controller.repo.initializeState<RepositoryPort, Controller>(\n      prevActions ? { ...prevActions.get(), ...defaultObject } : defaultObject,\n      { methods, prevActions, provider: provider || prevActions?.savedProvider || this?.actions?.savedProvider }\n    );\n  } else {\n    repo = initRepository<RepositoryPort, Controller>(\n      defaultObject, \n      { provider: provider || this?.actions?.savedProvider, methods }\n    );\n  }\n\n  return (repo || controller?.repo?.actions || {}).sourceObj;\n}\n\n", "import { \n  IRepositoryService, \n  RepositoryService, \n  repositoryCreator,  \n  initRepository, \n  initializeState,  \n} from './repository';\n\nimport { reactProvider } from 'react-provider';\nconst repka: IRepositoryService = new RepositoryService() as IRepositoryService;\n\nrepka.initRepository = initRepository;\nrepka.initializeState = initializeState;\nrepka.actions = initRepository({}, { provider: reactProvider });\nrepka.__call = repositoryCreator;\n\nexport { repka, IRepositoryService };\n"],
  "mappings": ";;;;;;;;;AA8BO,IAAM,oBAAN,cAAgC,SAAS;AAAA,EAG9C,gBACE,MACA,SACM;AAAA,EAAC;AAAA,EAaT,cAAc;AACZ,UAAM;AACN,QAAI,UAAU;AACd,cAAU,IAAI,SAAc;AAC1B,aAAO,QAAQ,OAAO,GAAG,IAAI;AAAA,IAC/B;AACA,WAAO,OAAO,eAAe,SAAS,WAAW,SAAS;AAAA,EAC5D;AACF;AAUO,IAAM,iBAAwC,SACnD,MACA,UAII,CAAC,GACW;AAChB,QAAM,OAAO,OAAO,KAAK,QAAQ,CAAC,CAAC;AAEnC,QAAM,eAAkB,KAAK,OAAO,CAClC,MACA,SACG;AACH,QAAI;AACJ,QAAI,QAAQ,gBAAgB,UAAa,QAAQ,YAAY,IAAI,IAAI,MAAM,QAAW;AACpF,cAAQ,QAAQ,YAAY,IAAI,IAAI;AAAA,IACtC,WAAW,MAAM;AACf,cAAQ,KAAK,IAAI;AAAA,IACnB;AACA,WAAO,EAAE,GAAG,MAAM,CAAC,IAAI,GAAG,MAAM;AAAA,EAClC,GAAG,QAAQ,CAAC,CAAM;AAElB,SAAO;AAAA,IACL;AAAA,IACA,QAAQ;AAAA,IACR,QAAQ;AAAA,EACV;AACF;AAEO,IAAM,kBAAkB,SAC7B,MACA,UAA8D,CAAC,GACzD;AACN,MAAI,CAAC,QAAQ;AAAa,YAAQ,cAAc,MAAM;AACtD,MAAI,CAAC,QAAQ;AAAU,YAAQ,WAAW,MAAM,SAAS;AAEzD,QAAM,aAAa,eAAe,KAAW,MAAM,MAAM,OAAO;AAChE,OAAK,UAAU;AACjB;AAEA,SAAS,kBAAkB,SAAS;AAChC,QAAM,QAAQ,CAAC;AACf,MAAI,MAAM;AACV,KAAG;AACC,UAAM,KAAK,GAAG,OAAO,oBAAoB,GAAG,CAAC;AAAA,EACjD,SAAS,MAAM,OAAO,eAAe,GAAG;AAExC,SAAO,MAAM,KAAK,EAAE,OAAO,CAAC,GAAG,GAAG,QAAQ;AACvC,QAAI,KAAG,IAAI,IAAE,CAAC,KAAK,OAAO,QAAQ,CAAC,KAAK;AAAY,aAAO;AAAA,EAC9D,CAAC;AACL;AAEO,SAAS,kBAId,eACA,YACA,EAAE,SAAS,IAGP,CAAC,GACgE;AACrE,MAAI;AACJ,MAAI,OAAO;AAEX,MAAI,YAAY;AACd,UAAM,kBAAkB,kBAAkB,UAAU;AAEpD,cAAU,gBAAgB;AAAA,MACxB,CAAC,MAAM,SAAU,SAAS,iBAAiB,OAAO,WAAW,IAAI,MAAM,aACnE,EAAE,GAAG,MAAM,CAAC,IAAI,GAAG,WAAW,IAAI,EAAE,KAAK,UAAU,EAAE,IACrD;AAAA,MACJ,CAAC;AAAA,IACH;AAEA,UAAM,cAAc,WAAW,MAAM;AACrC,eAAW,OAAO,IAAI,kBAAkB;AACxC,eAAW,KAAK,iBAAiB;AACjC,eAAW,KAAK,kBAAkB;AAClC,eAAW,KAAK;AAAA,MACd,cAAc,EAAE,GAAG,YAAY,IAAI,GAAG,GAAG,cAAc,IAAI;AAAA,MAC3D,EAAE,SAAS,aAAa,UAAU,YAAY,aAAa,iBAAiB,MAAM,SAAS,cAAc;AAAA,IAC3G;AAAA,EACF,OAAO;AACL,WAAO;AAAA,MACL;AAAA,MACA,EAAE,UAAU,YAAY,MAAM,SAAS,eAAe,QAAQ;AAAA,IAChE;AAAA,EACF;AAEA,UAAQ,QAAQ,YAAY,MAAM,WAAW,CAAC,GAAG;AACnD;;;ACvJA,IAAM,QAA4B,IAAI,kBAAkB;AAExD,MAAM,iBAAiB;AACvB,MAAM,kBAAkB;AACxB,MAAM,UAAU,eAAe,CAAC,GAAG,EAAE,UAAU,cAAc,CAAC;AAC9D,MAAM,SAAS;",
  "names": []
}
